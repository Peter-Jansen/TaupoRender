Group {
 name TaupoRender
 knobChanged "n = nuke.thisNode()\ntk = nuke.thisKnob()\n\nif tk.name() == 'use_camera':\n    # nuke.message('hello')\n    if tk.value():\n        n.knob('custom_fstop').setFlag(nuke.INVISIBLE)\n        n.knob('custom_focus_dist').setFlag(nuke.INVISIBLE)\n    else:\n        n.knob('custom_fstop').clearFlag(nuke.INVISIBLE)\n        n.knob('custom_focus_dist').clearFlag(nuke.INVISIBLE)"
 tile_color 0x9c0000ff
 selected true
 addUserKnob {20 User l "Taupo Render"}
 addUserKnob {26 taupo_render_title l "" t "Because Krakatoa used to be a sweet particle renderer, and Taupo is a supervolcano in New Zealand. " +STARTLINE T "<font size=\"+5\"> Taupo Render"}
 addUserKnob {26 about l "" +STARTLINE T "<font style=\"color: #666666;\">v0.91 | <a href=\"https://www.linkedin.com/in/petejans/\" style=\"color: #6786b8;\">Peter Jansen</a>"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {6 CPU_farm l "Always use CPU on render" -STARTLINE}
 CPU_farm true
 addUserKnob {41 reloadKernelSourceFile l Load +INVISIBLE T BlinkScript3.reloadKernelSourceFile}
 addUserKnob {41 kernelSourceFile l "Kernel File" +INVISIBLE T BlinkScript3.kernelSourceFile}
 addUserKnob {26 global_text l <b>Global}
 addUserKnob {41 format l "output format" T Reformat2.format}
 addUserKnob {4 merge_operation l "merge mode" M {additive over ""}}
 addUserKnob {4 holdout_style l "holdout depth math" -STARTLINE M {real "1/z (nuke)" ""}}
 holdout_style "1/z (nuke)"
 addUserKnob {7 overscan R 0 100}
 addUserKnob {7 z_blend_distance l "z blend"}
 addUserKnob {26 size_text l <b>Size}
 addUserKnob {7 size_mult l "size multiplier" R 0 10}
 size_mult 0.1
 addUserKnob {7 min_size l "min size" R 0 2}
 addUserKnob {7 softness}
 softness 0.5
 addUserKnob {26 text_2 l "<b>Depth of Field"}
 addUserKnob {6 enable_dof l "enable DoF" +STARTLINE}
 addUserKnob {6 use_camera l "Use camera input" -STARTLINE}
 addUserKnob {4 scene_units l "scene units" M {mm cm dm m inch ft}}
 scene_units dm
 addUserKnob {26 ""}
 addUserKnob {7 custom_fstop l fStop R 0 24}
 custom_fstop 8
 addUserKnob {7 custom_focus_dist l "focus distance" R 0 100}
 custom_focus_dist 10
 addUserKnob {26 ""}
 addUserKnob {7 cateye R -1 1}
 addUserKnob {7 cateye_softness l "cateye softness"}
 cateye_softness 0.5
 addUserKnob {26 text l <b>Replicator}
 addUserKnob {3 duplicates}
 addUserKnob {7 duplicate_radius l radius}
 duplicate_radius 0.1
 addUserKnob {26 dist_fade_text l "<b>Fade by Distance"}
 addUserKnob {7 fade_near l near R 0 100}
 addUserKnob {7 fade_near_falloff l "near falloff" R 0 100}
 addUserKnob {7 fade_far l far R 0 1000}
 fade_far 1000
 addUserKnob {7 fade_far_falloff l "far falloff" R 0 100}
 addUserKnob {7 falloff_gamma l gamma}
 falloff_gamma 1
 addUserKnob {26 mb_text l "<b>Motion Blur"}
 addUserKnob {7 shutter R 0 2}
 shutter 0.5
 addUserKnob {4 shutter_type l "shutter offset" +INVISIBLE M {start centered end ""}}
 shutter_type centered
 addUserKnob {41 Taupo_Render__minSteps l "min steps" T BlinkScript3.Taupo_Render__minSteps}
 addUserKnob {3 max_steps l "max steps" -STARTLINE}
 max_steps 64
 addUserKnob {7 spacing R 0 10}
 spacing 1
 addUserKnob {26 ""}
 addUserKnob {20 advanced_tab l Advanced}
 addUserKnob {26 text_1 l "" +STARTLINE T "This is where I throw variables that are actively being worked on,<br> are temporary solutions, or just don't really make sense to expose<br> to the average artist"}
 addUserKnob {6 diagnosticsMode l "diagnostics mode" +STARTLINE}
 addUserKnob {41 Taupo_Render__screenclip l _screenclip T BlinkScript3.Taupo_Render__screenclip}
}
 Input {
  inputs 0
  name holdout
  xpos 274
  ypos 455
  number 2
 }
set N60d6d400 [stack 0]
 Expression {
  expr0 "isinf(1/z)? 100000 : 1/z"
  name Expression1
  xpos 333
  ypos 520
 }
push $N60d6d400
 Expression {
  expr0 z
  name Expression2
  xpos 226
  ypos 521
 }
 Switch {
  inputs 2
  which {{parent.holdout_style}}
  name Switch1
  xpos 274
  ypos 573
 }
 Dot {
  name Dot4
  xpos 308
  ypos 612
 }
 Reformat {
  type scale
  scale {{"1+ (parent.overscan/100)"}}
  resize none
  name Reformat3
  xpos 274
  ypos 644
 }
 Input {
  inputs 0
  name cache
  xpos 705
  ypos -137
 }
 Constant {
  inputs 0
  channels rgb
  format "32 32 0 0 32 32 1 32"
  name Constant1
  xpos 917
  ypos 68
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input0]"}}
  name Switch2
  xpos 705
  ypos 92
 }
 Dot {
  name Dot5
  xpos 739
  ypos 264
 }
set N60d0e800 [stack 0]
 Dot {
  name Dot6
  xpos 1008
  ypos 264
 }
set N60d0e400 [stack 0]
 Dot {
  name Dot7
  xpos 1167
  ypos 264
 }
add_layer {taupo_utility taupo_utility.size taupo_utility.age taupo_utility.life taupo_utility.norm_age}
 Shuffle2 {
  fromInput1 {{0} B}
  in1 taupo_utility
  fromInput2 {{0} B}
  mappings "4 taupo_utility.size 0 0 rgba.red 0 0 taupo_utility.age 0 1 rgba.green 0 1 taupo_utility.life 0 2 rgba.blue 0 2 taupo_utility.norm_age 0 3 rgba.alpha 0 3"
  name Shuffle2
  xpos 1133
  ypos 349
 }
 Dot {
  name Dot2
  xpos 1167
  ypos 748
 }
push $N60d0e400
add_layer {taupo_col taupo_col.red taupo_col.green taupo_col.blue taupo_col.alpha}
 Shuffle2 {
  fromInput1 {{0} B}
  in1 taupo_col
  fromInput2 {{0} B}
  mappings "4 taupo_col.red 0 0 rgba.red 0 0 taupo_col.green 0 1 rgba.green 0 1 taupo_col.blue 0 2 rgba.blue 0 2 taupo_col.alpha 0 3 rgba.alpha 0 3"
  name Shuffle1
  xpos 974
  ypos 356
 }
 Dot {
  name Dot3
  xpos 1008
  ypos 612
 }
push $N60d0e800
 Dot {
  name Dot1
  xpos 739
  ypos 405
 }
set N60d0cc00 [stack 0]
 TimeOffset {
  time_offset -1
  time ""
  name TimeOffset2
  xpos 825
  ypos 424
 }
push $N60d0cc00
 TimeOffset {
  time_offset 1
  time ""
  name TimeOffset1
  xpos 589
  ypos 417
 }
push $N60d0cc00
 Constant {
  inputs 0
  channels rgb
  format {{{parent.Reformat2.format}}}
  name RENDER_RES
  xpos 405
  ypos 715
 }
 Reformat {
  type scale
  scale {{"1+ (parent.overscan/100)"}}
  name Reformat1
  xpos 405
  ypos 787
 }
 BlinkScript {
  inputs 7
  kernelSourceFile C:/Users/peter.jansen/Documents/taupo.cpp
  recompileCount 657
  ProgramGroup 1
  KernelDescription "2 \"Taupo_Render\" iterate pixelWise b6f86e1b79802cc68328b4f55ceb3c8572b1432d5b64f4515292fd3a966a1db4 8 \"format_img\" Read Random \"src\" Read Random \"src_prev\" Read Random \"src_next\" Read Random \"col\" Read Random \"util\" Read Random \"holdout\" Read Random \"dst\" Write Random 45 \"paSize\" Float 1 AABAQA== \"minSize\" Float 1 AACAPw== \"softness\" Float 1 AACAPw== \"merge_operation\" Int 1 AAAAAA== \"camera_matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"camera_matrix_prev\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"camera_matrix_next\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"haperture\" Float 1 ppvEQQ== \"focal\" Float 1 AADAQQ== \"focal_prev\" Float 1 AAAAAA== \"focal_next\" Float 1 AAAAAA== \"fStop\" Float 1 MzOzQA== \"focus_distance\" Float 1 AADIQg== \"focus_distance_prev\" Float 1 AAAAAA== \"focus_distance_next\" Float 1 AAAAAA== \"pixel_aspect\" Float 1 AACAPw== \"cam_near\" Float 1 zczMPQ== \"cam_far\" Float 1 AAB6RA== \"win_roll\" Float 1 AAAAAA== \"win_translate_x\" Float 1 AAAAAA== \"win_translate_y\" Float 1 AAAAAA== \"win_scale_x\" Float 1 AAAAAA== \"win_scale_y\" Float 1 AAAAAA== \"render_res\" Int 2 AAAAAAAAAAA= \"overscan_pc\" Float 1 AAAAAA== \"scene_units\" Int 1 AgAAAA== \"enable_dof\" Int 1 AAAAAA== \"cateye_amount\" Float 1 AAAAAA== \"cateye_softness\" Float 1 AAAAAA== \"_duplicates_num\" Int 1 AAAAAA== \"duplicate_radius\" Float 1 AAAAPw== \"Steps\" Int 1 CgAAAA== \"_minSteps\" Int 1 AAAAAA== \"spacing\" Float 1 AACAPw== \"_shutter\" Float 1 AAAAPw== \"z_blend_distance\" Float 1 AAAAAA== \"near\" Float 1 AAAAAA== \"near_falloff\" Float 1 AAAAAA== \"far\" Float 1 AAB6RA== \"far_falloff\" Float 1 AAAAAA== \"falloff_gamma\" Float 1 AACAPw== \"_diagnosticMode\" Int 1 AAAAAA== \"holdout_toggle\" Int 1 AAAAAA== \"_screenclip\" Float 1 AAAAAA== \"clip_padding\" Float 1 AAAAAA== 45 \"_size\" 1 1 \"_minSize\" 1 1 \"softness\" 1 1 \"_merge_operation\" 1 1 \"camera_matrix\" 16 1 \"camera_matrix_prev\" 16 1 \"camera_matrix_next\" 16 1 \"haperture\" 1 1 \"focal\" 1 1 \"focal_prev\" 1 1 \"focal_next\" 1 1 \"fStop\" 1 1 \"focus_distance\" 1 1 \"focus_distance_prev\" 1 1 \"focus_distance_next\" 1 1 \"pixel_aspect\" 1 1 \"cam_near\" 1 1 \"cam_far\" 1 1 \"win_roll\" 1 1 \"win_translate_x\" 1 1 \"win_translate_y\" 1 1 \"win_scale_x\" 1 1 \"win_scale_y\" 1 1 \"render_res\" 2 1 \"overscan_pc\" 1 1 \"scene_units\" 1 1 \"enable_dof\" 1 1 \"cateye_amount\" 1 1 \"cateye_softness\" 1 1 \"_duplicates_num\" 1 1 \"_duplicate_radius\" 1 1 \"_maxSteps\" 1 1 \"_minSteps\" 1 1 \"_spacing\" 1 1 \"_shutter\" 1 1 \"z_blend_distance\" 1 1 \"near\" 1 1 \"near_falloff\" 1 1 \"far\" 1 1 \"far_falloff\" 1 1 \"falloff_gamma\" 1 1 \"_diagnosticMode\" 1 1 \"_holdout_toggle\" 1 1 \"_screenclip\" 1 1 \"clip_padding\" 1 1 36 \"format_imgconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"src_prevconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"src_nextconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"colconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"utilconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"_w\" Int 1 1 AAAAAA== \"_h\" Int 1 1 AAAAAA== \"src_w\" Int 1 1 AAAAAA== \"src_h\" Int 1 1 AAAAAA== \"sqSize\" Int 1 1 AAAAAA== \"image_aspect\" Float 1 1 AAAAAA== \"pixelsPerWorldUnit\" Float 1 1 AAAAAA== \"scene_multiplier\" Float 1 1 AAAAAA== \"scene_focus_distance\" Float 1 1 AAAAAA== \"scene_focus_distance_prev\" Float 1 1 AAAAAA== \"scene_focus_distance_next\" Float 1 1 AAAAAA== \"img_center\" Float 2 1 AAAAAAAAAAA= \"img_radius\" Float 1 1 AAAAAA== \"win_scale\" Float 2 1 AAAAAAAAAAA= \"win_translate\" Float 2 1 AAAAAAAAAAA= \"batch_size_x\" Int 1 1 AAAAAA== \"batch_size_y\" Int 1 1 AAAAAA== \"enable_cateye\" Bool 1 1 AA== \"p_matrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"p_matrix_prev\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"p_matrix_next\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"t\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"s\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"m\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"w2s\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"w2s_prev\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"w2s_next\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"clip_matrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"clip_matrix_prev\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"clip_matrix_next\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel Taupo_Render : ImageComputationKernel<ePixelWise> \{\n    Image<eRead, eAccessRandom, eEdgeConstant> format_img; \n    Image<eRead, eAccessRandom, eEdgeConstant> src; \n    Image<eRead, eAccessRandom, eEdgeConstant> src_prev;  \n    Image<eRead, eAccessRandom, eEdgeConstant> src_next;\n    Image<eRead, eAccessRandom, eEdgeConstant> col; \n    Image<eRead, eAccessRandom, eEdgeConstant> util; \n    Image<eRead, eAccessRandom, eEdgeClamped> holdout; \n    Image<eWrite, eAccessRandom, eEdgeClamped> dst; \n\nparam:\n    float _size;\n    float _minSize;\n    float softness;\n    int _merge_operation;\n    \n    // Camera matrices\n    float4x4 camera_matrix;\n    float4x4 camera_matrix_prev;\n    float4x4 camera_matrix_next;\n\n    // Camera \n    float haperture;\n    float focal, focal_prev, focal_next;\n    float fStop;\n    float focus_distance, focus_distance_prev, focus_distance_next;\n    float pixel_aspect;\n    float cam_near;\n    float cam_far;\n    float win_roll;\n    float win_translate_x, win_translate_y;\n    float win_scale_x, win_scale_y;         // not passing these in as float2 because float2 shows UI in the main tool.\n\n    int2 render_res;\n    float overscan_pc;\n\n    // Depth of Field\n    int scene_units;\n    int enable_dof;\n    float cateye_amount;\n    float cateye_softness;\n\n    //Replicator\n    int _duplicates_num;\n    float _duplicate_radius;\n\n    // Motion blur and steps\n    int _maxSteps;\n    int _minSteps;\n    float _spacing;\n    float _shutter;\n\n    // Holdout\n    float z_blend_distance;\n    // Fade by distance\n    float near;\n    float near_falloff;\n    float far;\n    float far_falloff;\n    float falloff_gamma;\n\n    // other\n    int _diagnosticMode;\n    int _holdout_toggle;\n    float _screenclip;\n    float clip_padding;\n\nlocal:\n    int _w, _h;\n    int src_w, src_h;\n    int sqSize;\n    float image_aspect;\n    float pixelsPerWorldUnit;\n    float scene_multiplier;\n    float scene_focus_distance;\n    float scene_focus_distance_prev;\n    float scene_focus_distance_next;\n    float2 img_center;\n    float img_radius;\n\n    float2 win_scale;\n    float2 win_translate;\n\n    int batch_size_x;\n    int batch_size_y;\n\n    bool enable_cateye;\n\n    // projection matrix stuff. This is copying the one nuke provides in nukescripts.snap3d.py\n    float4x4 p_matrix, p_matrix_prev, p_matrix_next;         // projection matrix\n    float4x4 t;         // translate projected points into normalsed pixel coords (from 0,0 to -2,2 instead of -1,-1 to 1,1)\n    float4x4 s;         // scale normalised screen coords to actual pixel coords\n    float4x4 m;         // camera projection knobs (window roll, translate, scale)  \n    float4x4 w2s;       // final world to screen matrix. This matches the one provided by this node (ParticleBlinkScriptRender),\n    float4x4 w2s_prev;  // world to screen matrix of previous frame\n    float4x4 w2s_next;  // world to screen matrix of next frame\n\n    float4x4 clip_matrix;\n    float4x4 clip_matrix_prev;\n    float4x4 clip_matrix_next;\n\n\n\n  void define()\{\n\n    defineParam(_size, \"paSize\", 3.0f);\n    defineParam(_minSize, \"minSize\", 1.0f);\n    defineParam(softness, \"softness\", 1.0f);\n    defineParam(_merge_operation, \"merge_operation\", 0);\n\n    defineParam(camera_matrix, \"camera_matrix\", float4x4(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f) );\n    defineParam(haperture, \"haperture\", 24.576f);\n    defineParam(focal, \"focal\", 24.0f);\n    defineParam(fStop, \"fStop\", 5.6f);\n    defineParam(focus_distance, \"focus_distance\", 100.0f);\n    defineParam(pixel_aspect, \"pixel_aspect\", 1.0f);\n    defineParam(cam_near, \"cam_near\", 0.1f);\n    defineParam(cam_far, \"cam_far\", 1000.0f);\n    defineParam(scene_units, \"scene_units\", 2);\n    defineParam(enable_dof, \"enable_dof\", 0);\n\n    defineParam(cateye_amount, \"cateye_amount\", 0.0f);\n\n    defineParam(_duplicates_num, \"_duplicates_num\", 0);\n    defineParam(_duplicate_radius, \"duplicate_radius\", 0.5f);\n\n    defineParam(_maxSteps, \"Steps\", 10);\n    defineParam(_spacing, \"spacing\", 1.0f);\n    defineParam(_shutter, \"_shutter\", 0.5f);\n    \n    defineParam(clip_padding, \"clip_padding\", 0.0f);\n\n    //fade params\n    defineParam(near, \"near\", 0.0f);\n    defineParam(near_falloff, \"near_falloff\", 0.0f);\n    defineParam(far, \"far\", 1000.0f);\n    defineParam(far_falloff, \"far_falloff\", 0.0f);\n    defineParam(falloff_gamma, \"falloff_gamma\", 1.0f);\n\n    defineParam(_diagnosticMode, \"_diagnosticMode\", 0);\n    defineParam(_holdout_toggle, \"holdout_toggle\", 0);\n  \}\n\n  float4 srcOver( float4 a, float4 b ) \{\n    return (1.0f-a.w)*b + a;\n  \}\n\n  float2 transform( float3 p,float4x4 world_to_screen )\n  \{\n    float4 r = world_to_screen*float4(p.x, p.y, p.z, 1.0);\n    return float2(r.x, r.y)/r.w;\n  \}\nfloat3 transformz( float3 p, float4x4 world_to_screen )\{\n    float4 r = world_to_screen*float4(p.x, p.y, p.z, 1.0);\n    float2 xy = float2(r.x, r.y)/r.w;\n    float depth = r.w;\n    return float3(xy, depth);\n  \}  \n\nfloat4 toClipSpace(float3 P, float4x4 clip_matrix)\{\n    float4 homogeneous_P = float4(P.x, P.y, P.z, 1.0);\n    return clip_matrix*homogeneous_P;\n\}\n\nfloat3 clipToNDC(float4 clip)\{\n    float4 clip_to_screen = s * t * clip;\n    return (float3(clip_to_screen.x/clip_to_screen.w, clip_to_screen.y/clip_to_screen.w, clip_to_screen.w));      // but keep w coordinate for depth. I like it more.. lol.\n\}\n\nfloat radians(float degrees)\{\n    float degToRad = 3.14159265359f / 180.0f; // Conversion factor\n    return degrees * degToRad; // Convert degrees to radians\n\}\n// Function to check if a 4D position is within the frustum with padding\nbool isInsideFrustum(float4 position, float padding) \{\n\n    // Clip space coordinates\n    float x = position.x;\n    float y = position.y;\n    float z = position.z;\n    float w = position.w;\n\n    // Frustum boundaries with padding\n    bool insideX = (x >= -w - padding) && (x <= w + padding);\n    bool insideY = (y >= -w - padding) && (y <= w + padding);\n    bool insideZ = (z >= -w) && (z <= w);\n    // bool insideZ = (z >= 0) && (z <= w);\n    return insideX && insideY && insideZ; \n\}\n\n  float smoothstep( float a, float b, float x ) \{\n    float t = clamp((x - a) / (b - a), 0.0, 1.0);\n    return t*t * (3.0f - 2.0f*t);\n  \}\n\n  // overloaded lerp with float, float2 and float3\n    float lerp(float a, float b, float t)\{\n        return a + t * (b-a);\n  \}\n    float2 lerp(float2 a, float2 b, float t) \{\n        return a + t * (b - a);\n  \}\n    float3 lerp(float3 a, float3 b, float t) \{\n        return a + t * (b - a);\n    \}\nfloat4x4 projectionMatrix(\n        const float focalLength,\n        const float horizontalAperture,\n        const float nearPlane,\n        const float farPlane)\n\{\n    float farMinusNear = farPlane - nearPlane;\n    return float4x4(\n        2 * focalLength / horizontalAperture, 0, 0, 0,\n        0, 2 * focalLength / horizontalAperture, 0, 0,\n        0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n        0, 0, -1, 0\n    );\n\}\n\n// thanks Erwan Leroy - https://erwanleroy.com/making-3d-lightning-in-nuke-using-blinkscript/\ninline float fract (float x) \{return x-floor(x);\}\ninline float random(float co) \{ return fract(sin(co*(91.3458f)) * 47453.5453f); \}\n\ninline float3 randomv(float3 seed)\{\n  float scramble = random(seed.x + seed.y * seed.z);\n  float3 rand;\n  rand.x = random(seed.x + scramble + 0.14557f + 0.47917f * seed.z)*2-1;\n  rand.y = random(seed.y * 0.214447f + scramble * 47.241f * seed.x)*2-1;\n  rand.z = random(seed.z * scramble + 3.147855f + 0.2114f * seed.y)*2-1;\n  return normalize(rand);\n\}\n\ninline float3 randomv2(float seed)\{\n    //float scramble = random(seed + seed * seed);\n    float3 rand;\n    rand.x = random(seed + 0.215568f)*2.0-1.0;\n    rand.y = random(seed + 2.112408f)*2.0-1.0;\n    rand.z = random(seed + 68.13384f)*2.0-1.0;\n    return rand;\n\}\n\n\n\n\n  void init() \{\n\n    _w = dst.bounds.width();\n    _h = dst.bounds.height();\n    src_w = src.bounds.width();\n    src_h = src.bounds.height();\n    sqSize = src_w / 2;\n    img_center = float2(float(_w) * 0.5, float(_h) * 0.5);\n    img_radius = length(float2(float(render_res.x) * 0.5, float(render_res.y) * 0.5));\n    win_translate = float2(win_translate_x, win_translate_y);\n    win_scale = float2(win_scale_x, win_scale_y);\n    enable_cateye = enable_dof && cateye_amount != 0.0;\n\n    // How many times does the cache fit into the dst image? Round to nearest integer.\n    batch_size_x = ceil( float(src_w) / float(_w)); \n    batch_size_y = ceil( float(src_h) / float(_h)); \n    image_aspect = float(render_res.y) / float(render_res.x);\n    pixelsPerWorldUnit = (float(render_res.x)*0.5) / haperture; // RENDERED RESOLUTION WIDTH, not overscanned image width.\n\n    // camera projection matrix\n    p_matrix = projectionMatrix(focal, haperture, cam_near, cam_far);\n    p_matrix_prev = projectionMatrix(focal_prev, haperture, cam_near, cam_far);\n    p_matrix_next = projectionMatrix(focal_next, haperture, cam_near, cam_far);\n\n    \n\n    // camera projection knobs (window roll, translate, scale)\n    m.setIdentity();\n    m.scale(float4(1.0f/win_scale.x, 1.0f/win_scale.y, 1.0f, 1.0f));\n\tm.rotateZ(radians(win_roll));\n    m.translate(float4(-win_translate.x*2.0, -win_translate.y*2.0, 0.0f, 1.0f));\n    m.scale(float4(1.0f/(1.0f+overscan_pc*0.01),1.0f/(1.0f+overscan_pc*0.01),1.0f,1.0f));\n\n\n    // Matrix to scale normalised pixel coords into actual pixel coords.\n    float x_scale = float(_w) * 0.5;\n    float y_scale = x_scale *pixel_aspect;\n    s.setIdentity();\n    s.scale(float4(x_scale, y_scale, 1.0f,1.0f));\n\n    // Matrix to translate the projected points into normalised pixel coords\n    t.setIdentity();\n    t.translate(float4(1.0, 1.0 - (1.0 - image_aspect / pixel_aspect), 0.0f, 1.0f));\n\n    // view matrix is inverted camera world matrix\n    float4x4 view =  camera_matrix.invert();\n    float4x4 view_prev =  camera_matrix_prev.invert();\n    float4x4 view_next =  camera_matrix_next.invert();\n    \n    clip_matrix = m *p_matrix *  view;\n    clip_matrix_prev = m * p_matrix_prev * view_prev;\n    clip_matrix_next = m *p_matrix_next *  view_next;\n\n    // world to screen matrix is the concatenation of above matrices, from right to left.\n    w2s = s * t * p_matrix * m * view;\n    w2s_prev = s * t * p_matrix_prev * m * view_prev;\n    w2s_next = s * t * p_matrix_next * m * view_next;\n\n\n    float cm = 10.0f;\n    float dm = 100.0f;\n    float m = 1000.0f;\n    float inch = 25.4f;\n    float feet = 304.8f;\n    \n    scene_multiplier = (scene_units == 1) ? cm :\n                   (scene_units == 2) ? dm :\n                   (scene_units == 3) ? m :\n                   (scene_units == 4) ? inch :\n                   (scene_units == 5) ? feet : 1;\n    scene_focus_distance = focus_distance * scene_multiplier;\n    scene_focus_distance_prev = focus_distance_prev * scene_multiplier;\n    scene_focus_distance_next = focus_distance_next * scene_multiplier;\n    \n  \}\n\n// Thanks Jed Smith for OpticalZDefocus - circle of confusion math taken from there.\nfloat CoC(float depth, float f, float fd)\{\n    float scene_depth = depth * scene_multiplier;\n    float coc = (fabs(fd - scene_depth) * pow(f, 2) / (fStop * scene_depth * (fd - f)));\n    float coc_pixels = fabs(coc / haperture * float(render_res.x) );\n    return coc_pixels;\n\}\n\n\n// variation of the renderPoint function from the default code inside the ParticleBlinkScriptRender node. \n// Modified to do CoC calculations and take in a falloff\nvoid renderPoint( float2 xy, float4 pcolor, float pointSize, float coc, float falloff, float depth )\n\{\n\n\n    float effectiveRadius;\n    float effectiveRadius2;\n    float energyScale;\n    float2 cat_vec;\n    float cateye_limit;\n    float2 cateye_xy;\n\n    \n    // Effective radius (original particle size plus defocus)\n    if (enable_dof)\{\n        effectiveRadius = pointSize + coc;\n        effectiveRadius2 = effectiveRadius * effectiveRadius;\n        energyScale = (pointSize * pointSize) / (effectiveRadius2);\n    \}\n    else\{\n        effectiveRadius = pointSize;\n        effectiveRadius2 = pointSize*pointSize;\n        energyScale = 1.0f;\n    \}\n    if (enable_cateye)\{\n        cat_vec = float2(xy - img_center);\n\n        cateye_limit = cateye_amount * effectiveRadius *2.0;\n\n        cateye_xy = xy + (((xy - img_center) / img_radius) * cateye_limit);\n    \}\n\n    int intRadius = int(ceil(effectiveRadius));\n    int minX = max(0, int(xy.x) - intRadius);\n    int maxX = min(_w - 1, int(xy.x) + intRadius);\n    int minY = max(0, int(xy.y) - intRadius);\n    int maxY = min(_h - 1, int(xy.y) + intRadius);\n\n    float soft_thresh = effectiveRadius2 * (1.0 - softness);\n    float cateye_soft_thresh = effectiveRadius2 * (1.0 - cateye_softness);\n\n    // Loop over all pixels in the bounding box.\n    for (int y = minY; y <= maxY; y++) \{\n        for (int x = minX; x <= maxX; x++) \{\n            bool holdout_mask = true;\n            float holdout_alpha = 1.0f;\n            float holdout_opacity = 1.0f;\n            float z_blend = 1.0f;\n\n            if (_holdout_toggle) \{\n                float4 read_holdout = holdout(x,y);\n                float holdout_depth = read_holdout.x;\n                holdout_alpha = read_holdout.w;\n                holdout_opacity = 1.0f;\n                if (depth > holdout_depth ) \{ // behind the holdout\n                    if (holdout_alpha >=0.99999) holdout_mask = false;\n                    else\{\n                        holdout_mask = true;\n                        holdout_opacity = 1-holdout_alpha;\n                    \}\n                \}\n                else\{\n                        float dist_from_holdout = holdout_depth - depth;\n                        z_blend = smoothstep( 0.0, z_blend_distance, dist_from_holdout);\n                        z_blend = lerp(z_blend, 1.0, 1-holdout_alpha);\n                    \}\n            \}\n\n            if (holdout_mask)\{\n                float2 p = float2(x, y);\n                float2 d = p - xy;\n                float r2 = dot(d, d);\n                float2 cat;\n                float cat2;\n\n                bool render_mask;\n\n                if (enable_cateye)\{\n                    cat = p - cateye_xy;\n                    cat2 = dot(cat, cat);\n                    render_mask = r2 < effectiveRadius2 && cat2 < effectiveRadius2;\n                \}\n                else\{\n                    render_mask = r2 < effectiveRadius2;\n                \}\n\n                if (render_mask) \{\n\n                    float w = 1.0 - smoothstep(soft_thresh, effectiveRadius2, r2);\n                    float c =0.0;\n                    if (enable_cateye)\{\n                        c = 1.0 - smoothstep( cateye_soft_thresh, effectiveRadius2, cat2); \n                        w=w*c;\n                    \}\n                    w *= holdout_opacity;\n                    w *= energyScale * falloff;\n                    w *= z_blend;\n                    \n                    if (_diagnosticMode)\{\n                        dst(p.x, p.y) += float4(w, c, 1.0f, 0.0f);\n                    \}\n                    else\{\n                        // additive  \n                        if (_merge_operation == 0) \{ \n                            dst(p.x, p.y) += pcolor * w;\n                        \}\n\n                        // over\n                        if (_merge_operation == 1) \{\n                            float4 colourToAdd = pcolor * w;\n                            float4 existingColour = dst(p.x,p.y);\n                            dst(p.x, p.y) = srcOver(colourToAdd, existingColour);\n                        \}\n                    \}//diagonostics mode else end\n                \}\n            \}\n        \}\n    \}\n\}\n\n\n\n\n\n// Copilot \"think deeper\" finally gave me a function that will make a curve between 3 points\n// and ensure that the curve goes through all three. Thanks little AI!\nfloat2 quadraticInterpolation(float2 p0, float2 p1, float2 p2, float t) \{\n    // Lagrange basis polynomials\n    float l0 = (t - 0.5f) * (t - 1.0f) / ((0.0f - 0.5f) * (0.0f - 1.0f));\n    float l1 = (t - 0.0f) * (t - 1.0f) / ((0.5f - 0.0f) * (0.5f - 1.0f));\n    float l2 = (t - 0.0f) * (t - 0.5f) / ((1.0f - 0.0f) * (1.0f - 0.5f));\n    \n    // Interpolated point\n    return l0 * p0 + l1 * p1 + l2 * p2;\n\}\n\n  float minMaxSmooth(float n,float ns,float f,float fs,float v)\{\n      // input variables are near, near soft, far, far soft and value\n      float output = 0.0;\n      float near = min(n, f);\n      float near_soft = max(ns, 0.0);\n      float far = max(n, f);\n      float far_soft = max(fs, 0.0);\n\n      float near_soft_absolute = near-near_soft;\n      float far_soft_absolute = far+far_soft;\n\n      if (v <= near)\{\n        output = smoothstep(near_soft_absolute,near,v);\n        \}\n      else\{\n        output = 1-smoothstep(far,far_soft_absolute,v);\n        \}\n      return output;\n  \}\n\n    float screenSpaceSize(float focal_length, float p_size, float distance)\{\n        float particleSizeOnImagePlane = (focal_length * p_size) / distance;\n        float particleSizeInPixels = (particleSizeOnImagePlane * pixelsPerWorldUnit);\n    return particleSizeInPixels;\n  \}  \n\n\n  void process(int2 pos) \{\n    // blink runs on each pixel of the dst image. Every pixel, we'll sample the corresponding pixel in the src image (cache).\n    // But in the unlikely but not impossible scenario that the cache is larger than the destination image, then we won't hit\n    // those samples in the cache (say the cache is 2048x2048 and dst image is 1280x720. The cache is larger in both dimensions.\n    /*\n                _______________________              _______________________       \n                |                     |              |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|       \n                |         DST         |              |\\\\\\\\\\\\\\ CACHE \\\\\\\\\\\\\\|       \n                |__________           |              |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|       \n    Normally:   |         |           |   Oversized  |               |\\\\\\\\\\|       \n                |  CACHE  |           |     Cache:   |      DST      |\\\\\\\\\\|       \n                |         |           |              |               |\\\\\\\\\\|       \n                |_________|___________|              |_______________|_____|       \n    */\n    // The pixels in the shaded area of the cache will never be sampled.\n    // So we set up some batching, so that multiple pixels of the cache image will be sampled per dst image.\n    // We lose a little bit of concurrency, but there is an added benefit...\n    // There are fewer GPU scheduling conflicts causing artifacts when samples are overlapping in the 2d image.\n    // For this reason, we can also expose a batch size override, higher values = slower but less artifacts.\n    // Still, CPU gives best, artifact free results.\n    int2 batch_start;\n    int2 batch_end;\n    // if the batch size is 1, then no use \"batching\", just use the current pos in iteration space.\n    if (batch_size_x==1 && batch_size_y==1)\{\n        batch_start = int2(pos.x, pos.y);\n        batch_end = batch_start;\n    \}\n    // but if the batch size is larger, then establish where the batch coordinates are on the cache.\n    else\{\n    batch_start = int2 ( pos.x * batch_size_x, pos.y * batch_size_y);\n    batch_end = int2( batch_start.x + (batch_size_x-1), batch_start.y + (batch_size_y-1));\n    \}\n    // if the batch start point is outside of the cache image, then we're guaranteed to just be sampling nothing, so we return.\n    if (batch_start.x > src_w || batch_start.y > src_h) return; // should this be and or or... hmm. I think or??\n\n    for (int cache_x = batch_start.x; cache_x <= batch_end.x; cache_x++)\{\n        if (cache_x > src_w) break;\n\t    for (int cache_y = batch_start.y; cache_y <= batch_end.y; cache_y++)\{\n            if (cache_y > src_h) break; \n    \n    // Read position and ID for current frame\n    float4 read_pos_id = src(cache_x, cache_y);\n    int id = read_pos_id.w;\n    // Return if the id=0, ie, there's no particle\n    if(id == 0) return; \n    //Read position and ID for the prev and next frames\n    float4 read_pos_id_prev = src_prev(cache_x, cache_y);    \n    float4 read_pos_id_next = src_next(cache_x, cache_y);   \n    int id_prev = read_pos_id_prev.w;\n    int id_next = read_pos_id_next.w;\n    \n    // Read colour and utility data for just this frame\n    float4 read_col = col(cache_x, cache_y);\n    float4 read_util = util(cache_x, cache_y);\n\n    // Read other utility pass attributes\n    float world_size = read_util.x * _size;\n\n\n    // Create P attributes (split from ID)\n    float3 P = float3(read_pos_id.x, read_pos_id.y, read_pos_id.z);\n    float3 P_prev = float3(read_pos_id_prev.x, read_pos_id_prev.y, read_pos_id_prev.z);\n    float3 P_next = float3(read_pos_id_next.x, read_pos_id_next.y, read_pos_id_next.z);\n\n\n    // Handle new and dying particles\n    if (id_prev != id)\{                                      // if the particle is new, ie, it didn't exist last frame.\n        float3 vel = P_next - P;\n        P_prev = P - vel;\n    \}\n    if (id_next != id)\{                                     // if the particle is about to die, ie, won't exist next frame\n        float3 vel =  P - P_prev;\n        P_next = P+vel;\n    \}\n    if (id_next == 0 && id_prev == 0)\{                      // if the particle only exists on 1 frame\n        P_prev = P;\n        P_next = P;\n    \}\n\n    // if the particle is behind the camera, kill it.\n    float dist = transformz(P, w2s).z;\n    float dist_prev = transformz(P_prev, w2s).z;\n    float dist_next = transformz(P_next, w2s).z;\n    // if (dist<0.0f) return;\n    // float delete_dist = dist + _duplicate_radius;\n    // if (dist<0.0f && dist_next<0.0f && dist_prev<0.0f)\{ return;\}\n    \n\n\n\n    // Duplicate points\n    for (int pt = 0; pt <= _duplicates_num; pt++)\{\n\n    \n    // Apply a jitter to the duplicated points.\n    if (pt !=0)\{\n        float3 jitter = randomv2(float(pt) + float(id)*0.02)*_duplicate_radius;\n        P += jitter;\n        P_prev += jitter;\n        P_next += jitter;\n    \}\n\n    // Move P to clip space\n    float4 clip = toClipSpace(P, clip_matrix);\n    float4 clip_prev = toClipSpace(P_prev, clip_matrix_prev);\n    float4 clip_next = toClipSpace(P_next, clip_matrix_next);\n\n    if (!isInsideFrustum(clip,clip_padding) && !isInsideFrustum(clip_prev,clip_padding) && !isInsideFrustum(clip_next,clip_padding))\{\n        return;\n    \}\n\n\n    // move to NDC space\n    float3 ndc = clipToNDC(clip);\n    float3 ndc_prev = clipToNDC(clip_prev);\n    float3 ndc_next =  clipToNDC(clip_next);\n\n    // 2d position on screen of particle\n    float2 xy = float2(ndc.x, ndc.y);\n    float2 xy_prev = float2(ndc_prev.x, ndc_prev.y);\n    float2 xy_next = float2(ndc_next.x, ndc_next.y);\n\n\n    float blur_length = (length(xy - xy_prev) + length(xy - xy_next) * _shutter );\n    if (blur_length > (_screenclip*_w)) return;\n    \n    // Calculate 2d sizes\n    float size =      max(_minSize, min(100.0f, screenSpaceSize(focal, world_size, ndc.z)));\n    float size_prev = max(_minSize, min(100.0f, screenSpaceSize(focal_prev, world_size, ndc_prev.z)));\n    float size_next = max(_minSize, min(100.0f, screenSpaceSize(focal_next, world_size, ndc_next.z)));\n\n\n\n    float coc, coc_prev, coc_next;\n    coc = 0.0;\n    coc_prev = 0.0;\n    coc_next = 0.0; \n\n    if (enable_dof)\{\n    coc = max(0.0,min(200.0f, CoC(ndc.z, focal, scene_focus_distance)));\n    coc_prev = max(0.0,min(200.0f, CoC(ndc_prev.z, focal_prev, scene_focus_distance_prev)));\n    coc_next = max(0.0,min(200.0f, CoC(ndc_next.z, focal_next, scene_focus_distance_next)));\n    \}\n\n\n    float shutter_start = 0.5 - (_shutter*0.25);\n    float shutter_end = 0.5 + (_shutter*0.25);\n\n    float depth_fade = minMaxSmooth(near, near_falloff, far, far_falloff, ndc.z);\n    depth_fade = pow(depth_fade, falloff_gamma);\n    float4 render_col = read_col;\n    // render_col = float4(ndc,1);\n\n    int adaptive_from_size;\n\n    int steps;\n    if (_maxSteps <= 1)\{\n        renderPoint(xy,render_col , size, coc, depth_fade, ndc.z );\n    \}\n    else\{\n        // float blur_length = (length(xy - xy_prev) + length(xy - xy_next) * _shutter );\n        steps = max(2, min(_maxSteps, int(ceil(blur_length/max(2.0f, min(size_prev, size_next)+coc)*2.0/_spacing))));\n        adaptive_from_size = min(32, int(ceil(fabs(coc_prev-coc_next)*2.0)));\n        steps = max(_minSteps, steps);\n        steps += adaptive_from_size;\n        steps -= 1;\n\n        //steps = 32;\n\n        float shutter_start = 0.5 - (_shutter*0.25);\n        float shutter_end = 0.5 + (_shutter*0.25);\n\n        \n        render_col /= float(steps)+1;\n\n\n        for (int step = 0; step <= steps; step++)\{\n            float step_position = float(step)/float(steps);\n            float shutter_step = lerp(shutter_start, shutter_end, step_position);\n            float2 xy_render = quadraticInterpolation(xy_prev, xy, xy_next, shutter_step);\n            float coc_render = lerp(coc_prev, coc_next, shutter_step); \n            float size_render = lerp(size_prev, size_next, shutter_step);\n            renderPoint(xy_render,render_col, size_render,coc_render, depth_fade, ndc.z ); \n        \}\n    \}\n\n\n    \n    \} // end of point replication loop\n  \}\} // end of batch loops\n  \}  // end of process()\n  \}; // end of kernel"
  useGPUIfAvailable {{"use_gpu && !\[python nuke.executing()]"}}
  rebuild ""
  Taupo_Render_paSize {{parent.size_mult}}
  Taupo_Render_minSize {{parent.min_size}}
  Taupo_Render_softness {{parent.softness}}
  Taupo_Render_merge_operation {{parent.merge_operation}}
  Taupo_Render_camera_matrix {
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
    }
  Taupo_Render_camera_matrix_prev {
      {{parent.DummyCam.world_matrix(frame-1)} {parent.DummyCam.world_matrix(frame-1)} {parent.DummyCam.world_matrix(frame-1)} {parent.DummyCam.world_matrix(frame-1)}}
      {{parent.DummyCam.world_matrix(frame-1)} {parent.DummyCam.world_matrix(frame-1)} {parent.DummyCam.world_matrix(frame-1)} {parent.DummyCam.world_matrix(frame-1)}}
      {{parent.DummyCam.world_matrix(frame-1)} {parent.DummyCam.world_matrix(frame-1)} {parent.DummyCam.world_matrix(frame-1)} {parent.DummyCam.world_matrix(frame-1)}}
      {{parent.DummyCam.world_matrix(frame-1)} {parent.DummyCam.world_matrix(frame-1)} {parent.DummyCam.world_matrix(frame-1)} {parent.DummyCam.world_matrix(frame-1)}}
    }
  Taupo_Render_camera_matrix_next {
      {{parent.DummyCam.world_matrix(frame+1)} {parent.DummyCam.world_matrix(frame+1)} {parent.DummyCam.world_matrix(frame+1)} {parent.DummyCam.world_matrix(frame+1)}}
      {{parent.DummyCam.world_matrix(frame+1)} {parent.DummyCam.world_matrix(frame+1)} {parent.DummyCam.world_matrix(frame+1)} {parent.DummyCam.world_matrix(frame+1)}}
      {{parent.DummyCam.world_matrix(frame+1)} {parent.DummyCam.world_matrix(frame+1)} {parent.DummyCam.world_matrix(frame+1)} {parent.DummyCam.world_matrix(frame+1)}}
      {{parent.DummyCam.world_matrix(frame+1)} {parent.DummyCam.world_matrix(frame+1)} {parent.DummyCam.world_matrix(frame+1)} {parent.DummyCam.world_matrix(frame+1)}}
    }
  Taupo_Render_haperture {{DummyCam.haperture}}
  Taupo_Render_focal {{DummyCam.focal}}
  Taupo_Render_focal_prev {{DummyCam.focal(frame-1)}}
  Taupo_Render_focal_next {{DummyCam.focal(frame+1)}}
  Taupo_Render_fStop {{"use_camera ? DummyCam.fstop : parent.custom_fstop"}}
  Taupo_Render_focus_distance {{"use_camera ? DummyCam.focal_point : custom_focus_dist"}}
  Taupo_Render_focus_distance_prev {{"use_camera ? DummyCam.focal_point(frame - 1) : custom_focus_dist(frame-1)"}}
  Taupo_Render_focus_distance_next {{"use_camera ? DummyCam.focal_point(frame + 1) : custom_focus_dist(frame+1)"}}
  Taupo_Render_pixel_aspect {{"\[lindex \[value this.format] 6]"}}
  Taupo_Render_cam_near {{DummyCam.near}}
  Taupo_Render_cam_far {{DummyCam.far}}
  Taupo_Render_win_roll {{parent.DummyCam.winroll}}
  Taupo_Render_win_translate_x {{parent.DummyCam.win_translate.u}}
  Taupo_Render_win_translate_y {{parent.DummyCam.win_translate.v}}
  Taupo_Render_win_scale_x {{parent.DummyCam.win_scale.u}}
  Taupo_Render_win_scale_y {{parent.DummyCam.win_scale.v}}
  Taupo_Render_render_res {{RENDER_RES.width} {RENDER_RES.height}}
  Taupo_Render_overscan_pc {{overscan}}
  Taupo_Render_scene_units {{parent.scene_units}}
  Taupo_Render_enable_dof {{parent.enable_dof}}
  Taupo_Render_cateye_amount {{parent.cateye}}
  Taupo_Render_cateye_softness {{parent.cateye_softness}}
  Taupo_Render__duplicates_num {{parent.duplicates}}
  Taupo_Render_duplicate_radius {{parent.duplicate_radius}}
  Taupo_Render_Steps {{parent.max_steps}}
  Taupo_Render__minSteps 1
  Taupo_Render_spacing {{parent.spacing}}
  Taupo_Render__shutter {{parent.shutter}}
  Taupo_Render_z_blend_distance {{parent.z_blend_distance}}
  Taupo_Render_near {{parent.fade_near}}
  Taupo_Render_near_falloff {{parent.fade_near_falloff}}
  Taupo_Render_far {{parent.fade_far}}
  Taupo_Render_far_falloff {{parent.fade_far_falloff}}
  Taupo_Render_falloff_gamma {{1/parent.falloff_gamma}}
  Taupo_Render__diagnosticMode {{parent.diagnosticsMode}}
  Taupo_Render_holdout_toggle {{"\[exists parent.input2]"}}
  Taupo_Render__screenclip 5
  format "256 256 0 0 256 256 1 square_256"
  rebuild_finalise ""
  name BlinkScript3
  xpos 705
  ypos 681
 }
 Reformat {
  resize none
  pbb true
  name Reformat2
  xpos 705
  ypos 846
 }
set N60cd3400 [stack 0]
 Remove {
  operation keep
  channels rgba
  name Remove1
  xpos 705
  ypos 964
 }
 Input {
  inputs 0
  name cam
  xpos 454
  ypos -108
  number 1
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nadrianpueyo.com, 2019-2020"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  label "\[value \[value the_cam]name]"
  xpos 464
  ypos 342
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam}
  the_cam "\[\n#DummyCam v1.1. Updated 5 April 2020.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Camera3\" && \[class \$x] != \"Camera4\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera\"||\[class \$x]==\"Camera4\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 49
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 30
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 1000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 April 2020" T "<span style=\"color:#666\"><br/><b>DummyCam v1.1</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2020</span>"}
 }
push $N60cd3400
 Output {
  name Output1
  xpos 488
  ypos 1002
 }
end_group
